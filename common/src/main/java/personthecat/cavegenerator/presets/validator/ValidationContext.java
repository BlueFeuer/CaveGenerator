package personthecat.cavegenerator.presets.validator;

import com.mojang.datafixers.util.Either;
import org.hjson.JsonArray;
import org.hjson.JsonLiteral;
import org.hjson.JsonObject;
import org.hjson.JsonValue;
import personthecat.catlib.data.JsonPath;
import personthecat.catlib.data.MultiValueHashMap;
import personthecat.catlib.data.MultiValueMap;
import personthecat.catlib.exception.UnreachableException;
import personthecat.catlib.util.HjsonUtils;
import personthecat.cavegenerator.exception.DetailedPresetException;
import personthecat.cavegenerator.exception.PresetErrorsException;
import personthecat.cavegenerator.exception.PresetWarningsException;
import personthecat.cavegenerator.presets.CaveOutput;

import java.util.List;
import java.util.stream.Collectors;

public class ValidationContext {
    public final MultiValueMap<JsonPath, ValidationError> errors = new MultiValueHashMap<>();
    public final MultiValueMap<JsonPath, ValidationError> warnings = new MultiValueHashMap<>();

    void err(final JsonPath.Stub path, final String key, final Object... args) {
        this.errors.add(path.capture(), new ValidationError(key, args));
    }

    void warn(final JsonPath.Stub path, final String key, final Object... args) {
        this.warnings.add(path.capture(), new ValidationError(key, args));
    }

    public boolean hasErrors() {
        return !this.errors.isEmpty();
    }

    public boolean hasWarnings() {
        return !this.warnings.isEmpty();
    }

    public DetailedPresetException createErrorScreen(final String name, final CaveOutput preset) {
        return new PresetErrorsException(name, this.detail(this.errors, preset));
    }

    public DetailedPresetException createWarningScreen(final String name, final CaveOutput preset) {
        return new PresetWarningsException(name, this.detail(this.warnings, preset));
    }

    private JsonObject detail(final MultiValueMap<JsonPath, ValidationError> errors, final CaveOutput output) {
        final JsonObject details = (JsonObject) output.user.deepCopy();
        errors.forEach((path, list) -> {
            final JsonPath userPath = path.getClosestMatch(output.complete);
            this.copyGeneratedValues(details, output.complete, userPath);
            final List<String> messages = this.getMessages(list);
            userPath.getValue(details).ifPresent(v ->
                messages.forEach(v::appendComment));
        });
        return HjsonUtils.filter(details, errors.keySet());
    }

    private void copyGeneratedValues(final JsonObject json, final JsonObject source, final JsonPath path) {
        final int containerIndex = this.getLastContainer(path, json);
        final int valueIndex = containerIndex + 1;
        if (valueIndex + 1 >= path.size()) {
            return;
        }
        final JsonPath valuePath = path.subPath(0, valueIndex + 1);
        final JsonValue generated = valuePath.getValue(source).map(JsonValue::shallowCopy).orElseGet(() -> {
            final Either<String, Integer> type = path.get(valueIndex);
            return type.left().isPresent() ? new JsonObject() : new JsonArray();
        });
        final JsonValue replaced = valuePath.getValue(json).orElseGet(JsonLiteral::jsonNull);
        final String creator = replaced.isString() ? replaced.asString() : "<unknown source>";
        if (replaced.isObject() || replaced.isArray()) {
            HjsonUtils.setRecursivelyIfAbsent(replaced, generated);
        } else {
            valuePath.setValue(json, generated);
        }
        // Guarantee this gets added by doing it last.
        valuePath.getValue(json).ifPresent(v -> v.appendComment("Generated by: " + creator));
        // Prevent weird formatting issues with the comments.
        this.expandParent(json, path, containerIndex);
    }

    // Not very efficient, but much easier to read.
    private int getLastContainer(final JsonPath path, final JsonObject json) {
        final int available = path.getLastAvailable(json);
        final JsonValue value = path.subPath(0, available + 1)
            .getValue(json).orElseThrow(UnreachableException::new);
        return value.isObject() || value.isArray() ? available : available - 1;
    }

    private void expandParent(final JsonObject json, final JsonPath path, final int parent) {
        if (parent <= 0) {
            json.setCondensed(false);
            return;
        }
        path.subPath(0, parent).getValue(json).ifPresent(container -> {
            if (container.isArray()) {
                container.asArray().setCondensed(false);
            } else if (container.isObject()) {
                container.asObject().setCondensed(false);
            }
        });
    }

    private List<String> getMessages(final List<ValidationError> list) {
        return list.stream().flatMap(e -> e.format().stream()).collect(Collectors.toList());
    }
}
