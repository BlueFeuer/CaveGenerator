package personthecat.cavegenerator.presets.validator;

import org.hjson.JsonArray;
import org.hjson.JsonObject;
import org.hjson.JsonValue;
import personthecat.catlib.data.JsonPath;
import personthecat.catlib.data.MultiValueHashMap;
import personthecat.catlib.data.MultiValueMap;
import personthecat.catlib.util.HjsonUtils;
import personthecat.cavegenerator.exception.DetailedPresetException;
import personthecat.cavegenerator.exception.PresetErrorsException;
import personthecat.cavegenerator.exception.PresetWarningsException;
import personthecat.cavegenerator.presets.CaveOutput;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

public class ValidationContext {
    public final MultiValueMap<JsonPath, ValidationError> errors = new MultiValueHashMap<>();
    public final MultiValueMap<JsonPath, ValidationError> warnings = new MultiValueHashMap<>();

    void err(final JsonPath.Stub path, final String key, final Object... args) {
        this.errors.add(path.capture(), new ValidationError(key, args));
    }

    void warn(final JsonPath.Stub path, final String key, final Object... args) {
        this.warnings.add(path.capture(), new ValidationError(key, args));
    }

    public boolean hasErrors() {
        return !this.errors.isEmpty();
    }

    public boolean hasWarnings() {
        return !this.warnings.isEmpty();
    }

    public DetailedPresetException createErrorScreen(final String name, final CaveOutput preset) {
        return new PresetErrorsException(name, this.detail(this.errors, preset));
    }

    public DetailedPresetException createWarningScreen(final String name, final CaveOutput preset) {
        return new PresetWarningsException(name, this.detail(this.warnings, preset));
    }

    private JsonObject detail(final MultiValueMap<JsonPath, ValidationError> errors, final CaveOutput output) {
        final JsonObject details = (JsonObject) output.user.deepCopy();
        errors.forEach((path, list) -> {
            final JsonPath userPath = path.getClosestMatch(output.complete);
            this.createMissingLink(details, output.complete, userPath);
            final List<String> messages = this.getMessages(list);
            userPath.getValue(output.complete).ifPresent(v -> {
                userPath.setValue(details, v);
                messages.forEach(v::appendComment);
            });
        });
        return HjsonUtils.filter(details, errors.keySet());
    }

    private void createMissingLink(final JsonObject json, final JsonObject source, final JsonPath path) {
        final int last = path.getLastAvailable(json);
        final int next = last + 1;
        if (last < 0 || next == path.size()) {
            return;
        }
        final JsonPath generatorPath = path.subPath(0, next + 1);
        final JsonValue generated = generatorPath.getValue(source)
            .map(JsonValue::shallowCopy)
            .orElse(path.get(next).left().isPresent() ? new JsonObject() : new JsonArray());

        final String creator = this.getCreator(json, generatorPath);
        final Optional<JsonValue> replaced = generatorPath.getValue(json);
        if (replaced.isPresent() && (replaced.get().isObject() || replaced.get().isArray())) {
            HjsonUtils.setRecursivelyIfAbsent(replaced.get(), generated);
        } else {
            generatorPath.setValue(json, generated);
        }
        // Guarantee this gets added by doing it last.
        generatorPath.getValue(json).ifPresent(v -> v.appendComment("Generated by: " + creator));
        // Easier to see it this way, in case it was collapsed.
        this.expandParent(json, path);
    }

    private String getCreator(final JsonObject json, final JsonPath path) {
        final JsonValue s = path.getValue(json).orElse(null);
        if (s != null && s.isString()) {
            return s.asString();
        }
        return "<unknown source>";
    }

    private void expandParent(final JsonObject json, final JsonPath path) {
        final JsonValue parent = path.getLastContainer(json);
        if (parent.isArray()) {
            parent.asArray().setCondensed(false);
        } else if (parent.isObject()) {
            parent.asObject().setCondensed(false);
        }
    }

    private List<String> getMessages(final List<ValidationError> list) {
        return list.stream().flatMap(e -> e.format().stream()).collect(Collectors.toList());
    }
}
